#!/usr/bin/env python
import os.path
import argparse
import beets.ui
from beets import config
from beets.autotag import mb
from beets.ui.commands import TerminalImportSession
from beets.ui import print_, input_, decargs, show_path_changes, commands
from beets import importer
from beets.util import syspath, normpath, ancestry, displayable_path, pipeline
from beets import plugins
from pprint import pprint
from beets.autotag import Recommendation, AlbumMatch
from beetsplug.fetchart import FetchArtPlugin, CoverArtArchive, AlbumArtOrg, Amazon, Wikipedia, FanartTV
from beetsplug.lastgenre import LastGenrePlugin, LASTFM
import whatapi
import requests
import sys
import re


def get_year(path):
    return int(re.search('\d{4}', path.decode(sys.getfilesystemencoding())).group(0))

lastgenre = LastGenrePlugin()
valid_tags = set(['1960s', '1970s', '1980s', '1990s', '2000s', '2010s', 'alternative', 'ambient', 'black.metal', 'blues', 'classical', 'comedy', 'country', 'death.metal', 'deep.house', 'downtempo', 'drum.and.bass', 'dub', 'dubstep', 'electronic', 'experimental', 'folk', 'funk', 'gospel', 'grime', 'heavy.metal', 'hip.hop', 'house', 'idm', 'indie', 'instrumental', 'jazz', 'live', 'metal', 'noise', 'pop', 'pop.rock', 'post.punk', 'progressive.rock', 'psychedelic', 'punk', 'reggae', 'rhythm.and.blues', 'rock', 'shoegaze', 'ska', 'soul', 'synth.pop', 'techno', 'trance', 'video.game'])
def get_tags(album):
    last_obj = LASTFM.get_album(album.albumartist, album.album)
    result = set()
    for tag in lastgenre._tags_for(last_obj, lastgenre.config['min_weight'].get(int))[:3]:
        if tag in valid_tags:
            result.add(tag)
    if len(result) < 2:
        last_obj = LASTFM.get_artist(album.albumartist)
        for tag in lastgenre._tags_for(last_obj, lastgenre.config['min_weight'].get(int))[:3]:
            if tag in valid_tags:
                result.add(tag)
    return list(result)[:5]

class AutotunesFetchArt(FetchArtPlugin):
    def __init__(self):
        super().__init__()
        sources = [CoverArtArchive, AlbumArtOrg, Amazon, Wikipedia, FanartTV]
        self.sources = [s(self._log, self.config) for s in sources]


fetchart = AutotunesFetchArt()


class AlbumInfoToAlbum(object):
    def __init__(self, albuminfo):
        self.info = albuminfo

    def __getattr__(self, key):
        if key == "albumartist":
            key = "artist"
        elif key == "mb_albumid":
            key = "album_id"
        elif key == "mb_releasegroupid":
            key = "releasegroup_id"
        return getattr(self.info, key)


class NoneDict(dict):
    def __getitem__(self, key):
        return self.get(key)

@pipeline.stage
def resolve_duplicates(session, task):
    # TODO: check if it's already been uploaded
    return task


@pipeline.stage
def user_query(session, task):
    """A coroutine for interfacing with the user about the tagging
    process.

    The coroutine accepts an ImportTask objects. It uses the
    session's `choose_match` method to determine the `action` for
    this task. Depending on the action additional stages are executed
    and the processed task is yielded.

    It emits the ``import_task_choice`` event for plugins. Plugins have
    acces to the choice via the ``taks.choice_flag`` property and may
    choose to change it.
    """
    if not task or task.skip:
        return
    choice = session.choose_match(task)
    if not isinstance(choice, AlbumMatch):
        return
    if not choice.info.year and not choice.info.original_year:
        choice.info.original_year = choice.info.year = get_year(task.toppath)
    #resolve_duplicates(session, task)
    upload_album(session, task, choice)



@pipeline.stage
def lookup_candidates(session, task):
    if not task or task.skip: return
    task.lookup_candidates()
    return task


def upload_album(session, task, choice):
    album = AlbumInfoToAlbum(choice.info)
    image = fetchart.art_for_album(album, task.paths, False)
    if image and image.url:
        image_url = image.url
        if not image_url.endswith('.jpg'):
            image_url += '#.jpg'
    else:
        image_url = ""
    tags = get_tags(album)
    if len(tags) == 0:
        tags = input("tags: ").split(", ")
    album_dir = task.toppath.decode(sys.getfilesystemencoding())
    session.api.upload(album_dir, choice.info, tags, image_url)


class UploadSession(TerminalImportSession):
    def __init__(self, paths, username, password):
        self.want_resume = False
        self.config = NoneDict()
        self.api = whatapi.WhatAPI(username, password)
        super().__init__(None, None, paths, None)

    def run(self):
        stages = [
            importer.read_tasks(self),
            lookup_candidates(self),
            user_query(self)
        ]
        pl = pipeline.Pipeline(stages)
        pl.run_parallel(importer.QUEUE_SIZE)


def upload_files(paths, username, password):
    for path in paths:
        if not os.path.exists(syspath(normpath(path))):
            raise beets.ui.UserError(u'no such file or directory: {0}'.format(
                displayable_path(path)))

    session = UploadSession(paths, username, password)
    session.run()


def autotunes_main(args, lib=None):
    parser = argparse.ArgumentParser()
    parser.add_argument("username")
    parser.add_argument("album", help="path to the album you want to upload", nargs="+")
    args = parser.parse_args()
    mb.configure()
    password = input("password: ")
    upload_files(args.album, args.username, password)


beets.ui._raw_main = autotunes_main

if __name__ == "__main__":
    beets.ui.main()
