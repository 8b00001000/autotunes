#!/usr/bin/env python
import argparse
import beets.ui
import os.path
import re
import shutil
import string
import sys
import textwrap
import whatapi
from beets.autotag import AlbumMatch
from beets.autotag import mb
from beets import importer
from beetsplug.fetchart import FetchArtPlugin, CoverArtArchive, AlbumArtOrg, Amazon, Wikipedia, FanartTV
from beetsplug.lastgenre import LastGenrePlugin, LASTFM
from beets.ui.commands import TerminalImportSession
from beets.util import syspath, normpath, displayable_path, pipeline, sanitize_path


def get_year(path):
    return int(re.search('\d{4}', path.decode(sys.getfilesystemencoding())).group(0))


lastgenre = LastGenrePlugin()


valid_tags = set([
    '1960s', '1970s', '1980s', '1990s', '2000s', '2010s', 'alternative', 'ambient', 'black.metal', 'blues', 'classical',
    'comedy', 'country', 'death.metal', 'deep.house', 'downtempo', 'drum.and.bass', 'dub', 'dubstep', 'electronic',
    'experimental', 'folk', 'funk', 'gospel', 'grime', 'heavy.metal', 'hip.hop', 'house', 'idm', 'indie',
    'instrumental', 'jazz', 'live', 'metal', 'noise', 'pop', 'pop.rock', 'post.punk', 'progressive.rock', 'psychedelic',
    'punk', 'reggae', 'rhythm.and.blues', 'rock', 'shoegaze', 'ska', 'soul', 'synth.pop', 'techno', 'trance',
    'video.game'
])


def get_tags(album):
    last_obj = LASTFM.get_album(album.albumartist, album.album)
    result = set()
    for tag in lastgenre._tags_for(last_obj, lastgenre.config['min_weight'].get(int))[:3]:
        if tag in valid_tags:
            result.add(tag)
    if len(result) < 2:
        last_obj = LASTFM.get_artist(album.albumartist)
        for tag in lastgenre._tags_for(last_obj, lastgenre.config['min_weight'].get(int))[:3]:
            if tag in valid_tags:
                result.add(tag)
    return list(result)[:5]


class AutotunesFetchArt(FetchArtPlugin):
    def __init__(self):
        super().__init__()
        sources = [CoverArtArchive, AlbumArtOrg, Amazon, Wikipedia, FanartTV]
        self.sources = [s(self._log, self.config) for s in sources]


fetchart = AutotunesFetchArt()


class AlbumInfoToAlbum(object):
    def __init__(self, albuminfo):
        self.info = albuminfo

    def __getattr__(self, key):
        if key == "albumartist":
            key = "artist"
        elif key == "mb_albumid":
            key = "album_id"
        elif key == "mb_releasegroupid":
            key = "releasegroup_id"
        return getattr(self.info, key)


class NoneDict(dict):
    def __getitem__(self, key):
        return self.get(key)


@pipeline.stage
def process_album(session, task):
    if not task or task.skip:
        return

    choice = session.choose_match(task)
    if not isinstance(choice, AlbumMatch):
        return

    if not choice.info.year and not choice.info.original_year:
        try:
            choice.info.original_year = choice.info.year = get_year(task.toppath)
        except:
            # year not found - skip it
            return

    album = AlbumInfoToAlbum(choice.info)
    if not session.api.is_duplicate(album):
        upload_album(session, task, album)


@pipeline.stage
def lookup_candidates(session, task):
    if not task or task.skip:
        return

    task.lookup_candidates()
    return task


album_template = string.Template("$artist - $album ($year) [$format]")


def rename_album(album, album_dir):
    # TODO: more intelligent truncation
    path = album_template.substitute(
        artist=textwrap.shorten(album.artist, width=50, placeholder="_"),
        album=textwrap.shorten(album.album, width=40, placeholder="_"),
        year=album.year,
        format="FLAC"  # TODO
    )
    if album.catalognum:
        path += " {" + album.catalognum + "}"
    path = path.replace("/", "_").replace("\\", "_")
    path = sanitize_path(path)
    path = os.path.normpath(os.path.join(os.path.join(album_dir, ".."), path))
    shutil.move(album_dir, path)
    return path


def upload_album(session, task, album):
    image = fetchart.art_for_album(album, task.paths, False)
    if image and image.url:
        image_url = image.url
        if not image_url.endswith('.jpg'):
            image_url += '#.jpg'
    else:
        image_url = ""
    tags = get_tags(album)
    if len(tags) == 0:
        tags = input("tags: ").split(", ")
    album_dir = task.toppath.decode(sys.getfilesystemencoding())
    album_dir = rename_album(album, album_dir)
    session.api.upload(album_dir, session.output_dir, album, tags, image_url)


class UploadSession(TerminalImportSession):
    def __init__(self, paths, output_dir, username, password):
        self.want_resume = False
        self.config = NoneDict()
        self.output_dir = output_dir
        self.api = whatapi.WhatAPI(username, password)
        super().__init__(None, None, paths, None)

    def run(self):
        stages = [
            importer.read_tasks(self),
            lookup_candidates(self),
            process_album(self)
        ]
        pl = pipeline.Pipeline(stages)
        pl.run_parallel(importer.QUEUE_SIZE)


def upload_files(paths, output_dir, username, password):
    for path in paths:
        if not os.path.exists(syspath(normpath(path))):
            raise beets.ui.UserError(u'no such file or directory: {0}'.format(
                displayable_path(path)))

    session = UploadSession(paths, output_dir, username, password)
    session.run()


def autotunes_main(args, lib=None):
    parser = argparse.ArgumentParser()
    parser.add_argument("username")
    parser.add_argument("-o", "--output-dir",
                        help="the directory where torrents will be output",
                        default="/srv/torrents")
    parser.add_argument("album", help="path to the album you want to upload", nargs="+")
    args = parser.parse_args()
    mb.configure()
    password = input("password: ")
    upload_files(args.album, args.output_dir, args.username, password)


beets.ui._raw_main = autotunes_main

if __name__ == "__main__":
    beets.ui.main()
